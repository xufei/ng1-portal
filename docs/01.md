## Angular 1.x和ES6的结合

在Web前端技术飞速发展的今天，Angular 1.x可以说是一个比较老旧的东西，而ES6是新生事物。我们想要把这两个东西结合起来，感觉就好像“十八新娘八十郎，苍苍白发对红妆。”但这件事的难度也并不大，因为我们最终是要把ES6构建成ES5代码，而ES5代码是可以很容易和Angular 1.x协作的。

### 模块机制

Angular 1.x的module机制是比较别扭的，也是一种框架私有的模块机制，所以，我们需要淡化这层东西，具体的措施是：

- 把各功能模块的具体实现代码独立出来
- module机制作为一个壳子，对功能模块进行包装
- 每个功能分组，使用一个总的壳子来包装，减少上级模块的引用成本
- 每个壳子文件把module的name属性export出去

举例来说，我们有一个moduleA，里面有serviceA，serviceB，那么，就有这样一些文件：

*serviceA的实现，service/a.js*
```JavaScript
export default class ServiceA {}
```

*serviceB的实现，service/b.js*
```JavaScript
export default class ServiceB {}
```

*moduleA的壳子定义，moduleA.js*
```JavaScript
import ServiceA from "./services/a";
import ServiceB from "./services/b";

export default angular.module("moduleA", [])
	.service("ServiceA", ServiceA)
	.service("ServiceB", ServiceB)
	.name;
```

存在一个moduleB要使用moduleA：
```JavaScript
import moduleA from "./moduleA";

export default angular.module("moduleB", [moduleA]).name;
```

注意，这里为什么我们要export module的name呢？这是为了这个module的引用者方便，如果某个module改名了，所有依赖它的module可以不修改代码。

在这里我们可以看到，a.js，b.js，moduleA.js这三个文件，只有moduleA是作为一次性的配置项，而a和b可以尽量实现成框架无关的代码，这样将来的迁移代价会比较小。

### service，factory，controller，filter

在Angular 1.x里面，有factory和service两个概念，其实这两者可以替换，service传入的是构造函数，通过new创建出实例，而factory传入的是工厂函数，通过对这个工厂函数的调用而创建实例。

所以，如果要使用ES6代码来编写这个部分，也就很自然了：

*serviceA的实现，service/a.js*
```JavaScript
export default class ServiceA {}
```

*serviceA的模块包装器moduleA的实现*
```JavaScript
import ServiceA from "./service/a";

export angular.module("moduleA", [])
	.service("ServiceA", ServiceA)
	.name;
```

*factoryA的实现，factory/a.js*
```JavaScript
import EntityA from "./model/a";

export default function FactoryA {
	return new EntityA();
}
```

*factoryA的模块包装器moduleA的实现*
```JavaScript
import FactoryA from "./factory/a";

export angular.module("moduleA", [])
	.factory("FactoryA", FactoryA)
	.name;
```

注意看这个例子中，FactoryA函数的返回结果是new EntityA，在实际项目中，这里不一定是通过某个实体类创建的，也可能是直接一个对象字面量：

```JavaScript
export default function FactoryA {
	return {
		a: 1
	};
}
```

在ES6下，factory的定义其实可以有一些优化，比如说，我们可以不需要factory/a.js这个文件，也不需要这层factory封装，而是在module定义的地方，这样写：

```JavaScript
import EntityA from "./model/a";

export angular.module("moduleA", [])
	.factory("FactoryA", () => new EntityA())
	.name;
```

使用ES6定义controller的方式大致与service相同，

### 如何处理依赖注入

有一点值得注意，刚才我们提到的模块定义方式里，并没有考虑依赖注入，但实际业务中一般都要注入点东西，那怎么办呢？

有两种办法：

*controllers/a.js*
```JavaScript
export default class ControllerA {
	constructor(ServiceA) {
		this.serviceA = ServiceA;
	}
}

ControllerA.$inject = ["ServiceA"];
```

```JavaScript
import ControllerA from "./controllers/a";

export angular.module("moduleA", [])
	.controller("ControllerA", ControllerA);
```

或者：
*controllers/a.js*
```JavaScript
export default class ControllerA {
	constructor(ServiceA) {
		this.serviceA = ServiceA;
	}
}
```

```JavaScript
import ControllerA from "./controllers/a";

export angular.module("moduleA", [])
	.controller("ControllerA", ["ServiceA", ControllerA]);
```

个人推荐前一种，理由是，一个模块的依赖项声明，最好跟其实现放在一起，这样对可维护性更有利。

### directive

这个是终极纠结点了，因为一个directive，可能包含有compile，link等多个成员函数，各种配置项，一个可选controller之类，这里面我们要考虑这么一些东西：

- directive自身怎么定义为ES6代码
- 里面的各项成员如何处理
- controller如何定义

我们看一下directive主要包含些什么东西，它其实是一个ddo（Directive Definition Object），所以本质上这是一个对象，我们可以给它构建一个类。

```JavaScript
export default class DirectiveA {
}
```

DDO上面的东西大致可以分两类，属性和方法，所以就在构造函数里这样定义：

```JavaScript
constructor () {
	this.template = template;
	this.restrict = "E";
}
```

像这些都是基础的配置字符串，没什么特别的。剩下的就是controller和link，compile等函数了，这些东西其实也简单，比如controller，可以先实现一个普通controller类，然后赋值到controller属性上来：

```JavaScript
this.controller = ControllerA;
```

注意现在写directive，尽量使用controllerAs这样的语法，这样controller可以清晰些，不必注入$scope，而且还可以使用bindToController属性，把在attr上定义的属性或者方法直接传递到controller实例上来。

比如我们要做一个日期控件，最后合起来就是这样：

```JavaScript
import template from "../templates/calendar.html";
import CalendarCtrl from "../controllers/calendar";

import "../css/calendar.css";

export default class CalendarDirective {
	constructor() {
		this.template = template;
		this.restrict = "E";

		this.controller = CalendarCtrl;
		this.controllerAs = "calendarCtrl";
		this.bindToController = true;

		this.scope = {
			minDate: "=",
			maxDate: "=",
			selectedDate: "=",
			dateClick: "&"
		};
	}
	
	link (scope) {
		// 这段代码太别扭了，但问题是如果搬到controller里面去写成setter，会在constructor之前执行，真头疼，先这样吧
		scope.$watch("calendarCtrl.selectedDate", newDate => {
			if (newDate) {
				scope.calendarCtrl.calendar.year = newDate.getFullYear();
				scope.calendarCtrl.calendar.month = newDate.getMonth();
				scope.calendarCtrl.calendar.date = newDate.getDate();
			}
		});
	}
}
```

上面这个例子里，还有些比较头疼的地方。本来我们剥离了清晰的controller，就是为了里面不要有$scope这些奇奇怪怪的东西，但我们需要$watch这个selectedDate的赋值，就折腾了，$watch是定义在$scope上面的，而如果在controller上给selectedDate定义一个setter，可能由于babel跟angular共同的作用，时序有点问题……后面再想办法优化吧。

一个directive除了有这些，还可以有template的定义，所以在这个例子里我们也是用import把一个html加进来了，Webpack的html loader会自动把它变成一个字符串。

还有，组件化的思想指导下，单个组件也应当管理自己的样式，所以我们在这里也import了一个css，这个后面会被Webpack的css loader处理。