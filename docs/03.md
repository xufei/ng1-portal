## 构建一个动态的组件化平台

有时候，光有组件并不能完全满足我们的需求，因为需求的变更可能需要很多步骤才能映射到代码中去，而直接在代码中的修改，很多时候并不能很好地管控起来，我们有什么办法能够既灵活地应对需求的变更，又能很好地追踪变更过程和变更的位置呢？

答案就是，构建一个动态的组件化平台。

### 数据模型的建立

对于一个业务系统而言，最重要的部分是它的业务模型。所谓业务模型，包括数据、规则、流程等方面。如果使用编码的方式实现，我们可以编写出一个实体类，一些业务方法，一些业务流程，但如果这样做，就太死板了，每次有新需求的时候，会需要到处修改，我们可以尝试把这些东西做成可配置化的。

对于一个数据模型，通常有两种实现方式：一种是贫血的，数据实体上只存在属性，不存在方法，由外置的规则去操作这个实体；一种是充血的，实体上也有自己的一些方法，可以校验自身属性是否合法，可以操作实体的属性。在业务开发中，可以选用一种，也可以两者结合使用。

所以我们就可以这样去描述一个业务实体：

- 包含若干属性，每个属性的信息包括：属性名，属性类型，是否主键，是否必须等等，还可以设置默认值
- 包含若干方法，每个方法的信息包括：方法名，方法返回类型，参数列表，方法主体，是否异步等等

于是，就可以初步建立简单的配置界面了，为什么说初步，因为我们为了简化，暂时先没有考虑业务对象的关联，实际上，我们所使用的业务对象并不总是单层，由简单对象构成的，很可能存在引用关系，比如对象的某个属性是个数组，数组中的元素是我们建立的另外的业务对象，这些暂时先不谈，不影响我们的思路。

假设我们有了这层东西，可以干些什么呢？

设想一下，如果我们实例化这么一个对象，它已经能够表达一定业务含义了，我们只需要维护它和存储的关系（持久、易失），它就能够满足我们的基本需要了。注意，要把这个东西跑起来，在传统的语言比如Java中并不是那么简单，但在JS这种东西里，就容易很多。

比如说，对象上的方法，假设某个方法里带有this之类的东西，“return this.firstName + this.lastName”，你要给对象动态添加这个方法，并且能执行，还是很简单的，因为new Function就行了，并不需要做很多额外的事情，比如挨个解析方法体的文本。

还有一个注意点，我们看到方法上能够设置是否异步，有些方法是异步的，判定它们返回结果的方式会有所不同，所以需要加以区分。

### 业务流程

业务对象建立起来之后，我们就可以着手创建业务流程。所谓的业务流程是个什么东西呢？一般的工作流系统中，会把流程分为三类：

- 序列流程
- 状态机流程
- 规则流程

以状态机为例，一个业务可以分解为若干步骤，每个步骤称为一个环节，或者活动（Activity），而环节之间的跳转称为转移（Transition）。每个Activity上，会做某些事情。每个Transition上，配置了跳转条件和目的Activity。

一个流程启动的时候，会创建一个上下文（Context），这相当于流程中共享的变量区，在这里，我们可以实例化一些业务对象，也可以创建一些简单变量。

流程启动后，无条件进入初始Activity。每个Activity上可以有若干个流出的Transition，当活动执行完成后，会有输出结果，仅有匹配结果的那条Transition生效，然后流程流转到对应的Activity，进行后续操作。

一般情况下，流程流转若干步之后，就会到达结束状态，这时候流程结束。

Activity所做的事情，可以归结为对业务对象，或者流程变量的操作，而Transition所做的事情，是调用业务对象进行某种判定，或者对流程变量检验的结果。

### 通信与服务

我们前面做的这些准备，可以同时供前端后端使用，因为在现在这个时代，大家都可以用JS。那我们就需要给它们建立通信渠道。这里面的实现可以很多样化，比如通过RESTful接口，通过类似Meteor之类的接口，等等。

这一步是个难点，需要重点考虑。

### 界面的动态创建

现在我们再看看界面的部分，如何动态创建界面，这方面，其实不是难点，因为在全组件化的体系里，实际上只需要处理组件树的组合就可以了。

### 数据绑定

很少有人能做到这一步，但是，如果只做了前面的部分，不做这里，整个这个方案是不可能有人用的，所以，必须做。

这时候就能感觉到带绑定的MVVM框架的好了，嗯。